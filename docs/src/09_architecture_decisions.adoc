ifndef::imagesdir[:imagesdir: ../images]

[[section-design-decisions]]
== Architecture Decisions

=== ADR 1: Microservices architecture
* **Context:** The platform is expected to scale with increasing user demand, evolve over time with new features or game modes, and support parallel development by multiple team members. High availability and maintainability are important non-functional requirements.
* **Status:** Accepted by the teacher and development team.
* **Possible alternatives:**
** **Monolithic architecture:** where all game logic, API web and data storage services would be integrated in a single backend app.
Although it would have simplified the development at first, this solution presents big issues in terms of scalability and maintainability.
* **Decision:** We decided to implement a microservice-based architecture with a clear separation between game logic, data persistence, and presentation layers. The system will consist of:
** **Game Server (Rust)** handling core game rules, move validation, and bot strategies
** **Users Service (Node.js + Express + TypeScript)** managing authentication, database access, match persistence, and statistics (single point of database access)
** **React Frontend (Vite + TypeScript)** for user interaction, running entirely in the browser and coordinating API calls to backend services
** **Nginx API Gateway** routing requests and handling cross-cutting concerns (CORS, rate limiting, security)
** Persistent data managed through SQLite, accessible only by Users Service +
This approach allows each component to evolve independently while using the most appropriate technology for its responsibilities.
* **Pros:**
** Clear separation of concerns between game logic, data persistence, and user interface
** Enables independent development and deployment of Game Server and Users Service
** Single database access point (Users Service) ensures data consistency
** Nginx provides security isolation for backend services
* **Cons:**
** Increased architectural complexity compared to a single monolithic backend
** Introduces inter-service communication overhead and potential latency
** Frontend must coordinate multiple API calls for complex workflows

=== ADR 2: Rust for Game Server
* **Context:** The game server must be performant, safe, and reliable, as errors in the game logic could compromise fairness or stability. Additionally, the engine may need to handle multiple concurrent games and interact efficiently with other services in the system.
* **Status:** Accepted by the teacher and development team.
* **Possible alternatives:**
** There were no possible alternatives because this was an imposed constraint, given by the course's teachers.
* **Decision:** We decided to implement the Game Server using Rust, which provides strong compile-time guarantees for memory safety and concurrency without relying on a garbage collector. This makes it well-suited for implementing complex game logic that must be both efficient and robust. The Game Server will be completely stateless, with no database access.
* **Pros:**
** Strong memory safety guarantees, reducing runtime errors and crashes
** High performance and excellent support for concurrency, which is important for managing game sessions in parallel
** Stateless design enables horizontal scaling
* **Cons:**
** Steeper learning curve, as the development team is not familiar with this programming language

=== ADR 3: Docker Containerization
* **Context:** The platform is composed of multiple independent components implemented with different technologies and runtimes. A way to ensure consistent development, testing, and deployment across different environments is essential to reduce configuration issues and simplify setup for new team members.
* **Status:** Accepted by the teacher and development team.
* **Possible alternatives:**
** There were no possible alternatives because this was an imposed constraint, given by the course's teachers.
* **Decision:** We decided to containerize all major components of the system using Docker. Each service (React Frontend, Nginx, Users Service, Game Server) will run inside its own Docker container, with Docker Compose used to orchestrate and manage the multi-container setup. This ensures environment consistency and simplifies deployment and execution of the full system.
* **Pros:**
** Provides consistent environments across development, testing, and deployment
** Simplifies setup and onboarding by reducing manual configuration
** Enables easier deployment and scaling of individual services
** Isolated network for backend services through Docker networking
* **Cons:**
** Adds an extra layer of complexity to the development workflow
** Requires basic knowledge of Docker and container orchestration from the development team

=== ADR 4: SQLite as Database System
* **Context:** The application requires persistent storage for game data, user information, and match states. The database solution should be simple to operate, easy to integrate with the existing backend services, and appropriate for an academic project deployed in a cloud environment.
* **Status:** Proposed by the development team.
* **Possible alternatives:**
** **MongoDB:** A document-oriented NoSQL database was considered. It would allow the development team to store game states in a more flexible way, using JSON structures. This alternative was not adopted as the development team was not familiar with this kind of DBs when the decision was taken.
* **Decision:** We decided to use SQLite as the primary database system for the application. The SQLite database will be accessed exclusively by the Users Service - no other component has direct database access. This ensures data consistency and simplifies the persistence layer. This choice is also highly based on the development team's experience using relational databases.
* **Pros:**
** Easy integration with backend services and containerized environments
** Suitable for small-to-medium workloads
** Low learning curve, as the development team is used to working with relational databases
** Single point of access (Users Service) ensures data integrity
** Embedded database requires no separate server process
* **Cons:**
** Limited scalability and concurrency support compared to cloud-native database solutions
** Not ideal for high-availability or horizontally scaled write-heavy workloads

=== ADR 5: Nginx as API Gateway
* **Context:** The system requires a secure entry point for all external requests. Backend services (Users Service and Game Server) should not be directly accessible from the internet. Additionally, cross-cutting concerns such as CORS, rate limiting, and request routing need to be handled consistently.
* **Status:** Proposed by the development team.
* **Possible alternatives:**
** **Direct access to backend services:** Each service could expose its own public port, but this would increase security risks and make it harder to manage cross-cutting concerns.
** **Cloud API Gateway services (AWS API Gateway, Azure API Management):** These would provide more features but add complexity and cost for an academic project.
* **Decision:** We decided to use Nginx as a reverse proxy and API Gateway. Nginx will be the only component with a publicly exposed port (80). It will route requests based on URL paths:
** `/api/users/*` → Users Service (port 3000, internal)
** `/api/gamey/*` → Game Server (port 4000, internal)
** `/*` → React Frontend static files
Nginx will also handle CORS headers, rate limiting, and request logging.
* **Pros:**
** Single public entry point enhances security (defense in depth)
** Backend services are isolated on internal Docker network
** Centralized handling of CORS, rate limiting, and logging
** High performance and battle-tested in production environments
** Simple configuration and widely known by the development community
* **Cons:**
** Adds an additional component to the system architecture
** Requires learning Nginx configuration syntax
** Single point of failure (mitigated by its reliability)
