ifndef::imagesdir[:imagesdir: ../images]

[[section-solution-strategy]]
== Solution Strategy

=== Overview

This section outlines the fundamental architectural and technological decisions that shape the Yovi system. These decisions were made based on project requirements, quality goals, and technical constraints imposed by the academic context.

=== Technology Decisions

==== Distributed Architecture with Microservices

[cols="1,3", options="header"]
|===
| Decision | Rationale

| **Nginx as API Gateway**
a| • **Security**: Single public entry point isolates backend services from direct access
• **Routing**: Centralized request routing based on URL paths (`/api/users/*`, `/api/gamey/*`)
• **Cross-cutting concerns**: Handles CORS, rate limiting, and static file serving in one place
• **Performance**: Efficient reverse proxy with minimal overhead
• **Simplicity**: Easy configuration and widely adopted in production environments

| **Separate Game Server (Rust)**
a| • **Performance**: Rust provides memory safety without garbage collection, ensuring fast execution for game logic and move validation
• **Concurrency**: Rust's ownership model enables safe concurrent processing of multiple game sessions
• **Domain Separation**: Isolates core game logic from presentation and user management concerns
• **Requirement**: Mandated by project specification to implement game engine in Rust

| **Users Service (Node.js + Express + TypeScript)**
a| • **Rapid Development**: JavaScript/TypeScript ecosystem provides extensive libraries and tooling
• **Database Integration**: Excellent SQLite support with mature ORM options
• **REST API**: Express simplifies RESTful API implementation
• **Single DB Access Point**: Encapsulates all database operations in one service
• **Requirement**: TypeScript mandated by project specification

| **Frontend (React + Vite + TypeScript)**
a| • **Component-based UI**: React's declarative approach simplifies game board rendering and state management
• **Fast Development**: Vite provides instant hot module replacement (HMR) for rapid iteration
• **Type Safety**: TypeScript prevents runtime errors and improves code maintainability
• **SPA Architecture**: Single-page application enables smooth user experience without page reloads
• **Client-side coordination**: Frontend manages API call orchestration from the browser

| **Database (SQLite)**
a| • **Simplicity**: Zero-configuration embedded database, no separate server process required
• **Portability**: Single file database simplifies deployment and backup
• **Performance**: Excellent read performance for user statistics and rankings
• **Write-Ahead Logging (WAL)**: Enables concurrent reads during writes, sufficient for academic project scale
• **Low Concurrency**: Appropriate for expected user load in university project context
|===

=== Architectural Patterns

==== Microservices Architecture

[plantuml, solution-architecture, png]
----
@startuml
!define RECTANGLE rectangle

skinparam rectangle {
  BackgroundColor<<frontend>> LightGreen
  BackgroundColor<<gateway>> Orange
  BackgroundColor<<service>> LightYellow
}

actor "User (Browser)" as user

RECTANGLE "React Frontend\n(Webapp)" as frontend <<frontend>>
RECTANGLE "Nginx\n(API Gateway)" as nginx <<gateway>>
RECTANGLE "Users Service\n(Node.js)" as users <<service>>
RECTANGLE "Game Server\n(Rust)" as game <<service>>
database "SQLite" as db

user --> nginx : HTTP (80)
nginx --> frontend : Static files
nginx --> users : /api/users/*\nHTTP (3000)
nginx --> game : /api/gamey/*\nHTTP (4000)
frontend ..> nginx : API calls from browser
users --> db : Direct access

note right of nginx
  **API Gateway Responsibilities:**
  • Single entry point (port 80)
  • Request routing
  • CORS handling
  • Rate limiting
  • Static file serving
end note

note right of frontend
  **Frontend Responsibilities:**
  • Game UI rendering
  • User interaction handling
  • Client-side state management
  • API call coordination
  • Runs entirely in browser
end note

note right of users
  **Users Service Responsibilities:**
  • User authentication & authorization
  • Database access (single point)
  • Match persistence
  • Statistics aggregation
end note

note right of game
  **Game Service Responsibilities:**
  • Game logic (move validation)
  • Win condition checking
  • Bot move computation
  • Strategy implementations
  • Pure domain logic (stateless)
end note

@enduml
----

The system follows a **microservices architecture** where:

* **Nginx** acts as the API Gateway, providing a single entry point and routing requests to appropriate services
* **React Frontend** runs in the user's browser and coordinates API calls to backend services
* **Users Service** manages all data persistence and is the single point of database access
* **Game Server** remains stateless and focuses solely on game domain logic
* **YEN notation** defines the boundaries between services for game state communication

==== Layered Architecture within Services

[plantuml, layered-architecture, png]
----
@startuml

package "React Frontend (Browser)" {
  [Components] --> [State Management]
  [State Management] --> [API Layer]
  [API Layer] --> [HTTP Client]

  note right of Components
    React components
    UI rendering
  end note

  note right of [State Management]
    Game state
    User session
    Local storage
  end note
}

package "Users Service (Node.js)" {
  [Controllers] --> [Services]
  [Services] --> [Repositories]
  [Repositories] --> [Database]

  note right of Controllers
    REST endpoints
    Request/Response handling
  end note

  note right of Services
    Business logic
    Authentication
  end note
}

package "Game Server (Rust)" {
  [Engine Service] --> [Game Domain]
  [Game Domain] --> [Strategy Pattern]

  note right of [Game Domain]
    Core game rules
    Board representation
    Move validation
  end note

  note right of [Strategy Pattern]
    Multiple bot strategies
    Difficulty levels
    Extensible AI
  end note
}

@enduml
----

**React Frontend Layers:**

* **Components**: React UI components for board, moves, statistics
* **State Management**: Local game state and user session (React hooks/context)
* **API Layer**: Abstraction over backend API calls
* **HTTP Client**: Fetch/Axios for making HTTP requests to Nginx

**Users Service Layers:**

* **Controllers**: Handle HTTP requests, authentication, input validation
* **Services**: Business logic for users, matches, statistics
* **Repositories**: Abstract database access using Repository pattern
* **Database**: SQLite persistence layer

**Game Server Design:**

* **Domain-Driven Design**: Game, Board, Player, Move as core entities
* **Strategy Pattern**: Multiple bot strategies with configurable difficulty levels
* **Encapsulation**: Pure domain logic with no external dependencies

=== Quality Goals Achievement

[cols="2,3,3", options="header"]
|===
| Quality Goal | Strategy | Implementation

| **Performance**
a| • Rust for compute-intensive game logic
• SQLite for fast read operations
• Stateless game server for horizontal scaling
• Nginx for efficient request routing
a| • Move validation in O(n) time
• Indexed database queries for rankings
• Concurrent request handling in Rust
• Nginx caching for static files

| **Scalability**
a| • Stateless services enable horizontal scaling
• Database optimized for read-heavy workload
• Nginx can load balance multiple game server instances
a| • Multiple game server instances possible
• Connection pooling in Users Service
• Caching strategies for frequent queries
• Independent service scaling

| **Maintainability**
a| • Clear separation of concerns
• Type safety (TypeScript + Rust)
• Single database access point (Users Service)
a| • Layered architecture in each service
• Repository pattern for DB abstraction
• API documentation
• Shared YEN notation contracts

| **Interoperability**
a| • REST API with JSON
• Standardized YEN notation
• External bot API support
a| • HTTP-based communication
• Versioned API endpoints
• Cross-team bot competition support
• Well-defined API contracts

| **Security**
a| • Nginx isolates backend services
• Rate limiting and CORS at gateway level
• Authentication in Users Service
a| • JWT token-based authentication
• Password hashing (bcrypt/Argon2)
• No direct backend access
• Input validation at API boundaries
|===

=== Key Constraints

[cols="1,3", options="header"]
|===
| Constraint | Impact on Architecture

| **Mandated Technologies**
| TypeScript for frontend/backend and Rust for game engine are project requirements, limiting technology choices

| **YEN Notation**
| All game state communication must use YEN format, requiring parsing/serialization layers

| **Bot API Requirement**
| System must expose external API for bot clients, influencing authentication and API design

| **Academic Timeline**
| Limited development time favors familiar technologies (React, Express) and simple deployment (SQLite)

| **Web Deployment**
| Application must be publicly accessible, requiring containerization and reverse proxy strategy

| **Multiple Strategies**
| Game engine must support extensible bot strategies, leading to Strategy pattern adoption

| **Database Consistency**
| A single database access point through Users Service ensures data integrity
|===

=== Organizational Decisions

* **Monorepo structure**: All services in one repository (`webapp/`, `users/`, `gamey/`, `nginx/`) for easier coordination
* **Docker Compose**: Simplified local development with single command startup
* **Shared YEN notation**: Common understanding of game state format across all services
* **API-first approach**: Define API contracts before implementation
* **Version control**: Git with feature branch workflow and code reviews
* **Documentation**: arc42 for architecture, inline code documentation, README files per service
