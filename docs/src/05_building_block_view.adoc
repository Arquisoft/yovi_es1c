ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]
== Building Block View

=== Whitebox Overall System

==== Overview Diagram

[plantuml, level1-overview, png]
----
@startuml
!include <C4/C4_Component>

skinparam componentStyle rectangle

package "Yovi System" {
  component "Web Frontend\n(React + Vite + TS)" as frontend <<application>>
  component "Web App Server\n(Node.js + Express + TS)" as webapp <<service>>
  component "Game Server\n(Rust)" as gamey <<service>>
  database "SQLite Database" as db <<database>>
}

frontend -down-> webapp : HTTPS/REST\nJSON
webapp -right-> gamey : HTTP/REST\nJSON (YEN)
webapp -down-> db : SQLite\nSQL

note right of webapp
  **Backend for Frontend (BFF)**
  Orchestrates user management
  and game logic
end note

note right of gamey
  **Core Game Engine**
  Stateless game logic
  Move validation & bot AI
end note

@enduml
----

**Motivation:**

The Yovi system is decomposed into three main subsystems to achieve separation of concerns, independent scalability, and technology-specific optimization:

* **Web Frontend**: User interface layer for human players
* **Web App Server**: Orchestration layer (BFF pattern) managing authentication, match lifecycle, and API routing
* **Game Server**: Pure game logic engine optimized for performance (Rust)
* **Database**: Persistent storage for users, matches, and statistics

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Building Block | Responsibility

| **Web Frontend**
a| • Renders game board and UI components
• Handles user interactions (login, game moves, statistics viewing)
• Communicates with Web App Server via REST API
• Manages client-side state

| **Web App Server (BFF)**
a| • Acts as Backend for Frontend orchestrating multiple services
• Provides REST API for web clients and bots
• Manages user authentication and authorization
• Coordinates Game Server and Database operations
• Transforms between user-friendly formats and YEN notation

| **Game Server**
a| • Implements core Y game rules and logic
• Validates moves and checks win conditions
• Computes bot moves using various strategies
• Stateless service using YEN notation
• Exposes REST API for game operations

| **Database (SQLite)**
a| • Stores user accounts and credentials
• Persists match history and game state
• Maintains player statistics and rankings
• Provides atomic transactions for data consistency
|===

**Important Interfaces:**

* **Web Frontend → Web App Server**: REST API (`/auth/*`, `/matches/*`, `/play`, `/stats`)
* **Web App Server → Game Server**: REST API (`/ybot/choose/{botId}`)
* **Web App Server → Database**: SQLite native SQL queries
* **Bot Client → Web App Server**: REST API (`/bot/play`)

=== Level 2

==== White Box: Web App Server

[plantuml, level2-webapp, png]
----
@startuml
package "Web App Server (Node.js + Express + TypeScript)" {

  package "Controllers Layer" <<frame>> {
    component [AuthController] <<TS>>
    component [MatchesController] <<TS>>
    component [StatsController] <<TS>>
    component [BotApiController] <<TS>>
  }

  package "Services Layer" <<frame>> {
    component [GameOrchestrationService] <<TS>>
  }

  package "Clients Layer" <<frame>> {
    component [UsersClient] <<TS>>
    component [GameEngineClient] <<TS>>
  }
}

component "UsersService\n(External)" as users <<external>>
component "Game Server\n(External)" as game <<external>>
component "SharedContracts\n(DTOs)" as contracts <<library>>

[AuthController] ..> [GameOrchestrationService]
[MatchesController] ..> [GameOrchestrationService]
[StatsController] ..> [GameOrchestrationService]
[BotApiController] ..> [GameOrchestrationService]

[GameOrchestrationService] ..> [UsersClient]
[GameOrchestrationService] ..> [GameEngineClient]

[UsersClient] --> users : HTTP/JSON
[GameEngineClient] --> game : HTTP/JSON

[UsersClient] ..> contracts
[GameEngineClient] ..> contracts

note right of [GameOrchestrationService]
  **Orchestration Responsibilities:**
  - Coordinates UsersService calls
  - Validates game state
  - Calls Game Server for moves
  - Transforms YEN ↔ User formats
end note

@enduml
----

**Motivation:**

The Web App Server follows a layered architecture with clear separation between HTTP handling (Controllers), business orchestration (Services), and external communication (Clients). This enables:

* **Testability**: Each layer can be unit tested independently
* **Maintainability**: Changes to external APIs are isolated in Client classes
* **Reusability**: GameOrchestrationService can be used by multiple controllers

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **AuthController**
a| • Handles HTTP requests for `/auth/register` and `/auth/login`
• Validates user credentials
• Returns JWT tokens or session cookies

| **MatchesController**
a| • Manages match creation (`POST /matches`)
• Retrieves match history (`GET /matches`)
• Requires authentication

| **StatsController**
a| • Provides player statistics endpoint (`GET /stats`)
• Aggregates data from UsersService

| **BotApiController**
a| • Exposes bot-specific API (`POST /bot/play`)
• Handles bot authentication
• Delegates to GameOrchestrationService

| **GameOrchestrationService**
a| • Core orchestration logic
• Coordinates UsersClient and GameEngineClient
• Implements game flow: validate state → compute move → persist result
• Error handling and state management

| **UsersClient**
a| • HTTP client wrapping UsersService API
• Handles user authentication, match persistence, statistics retrieval

| **GameEngineClient**
a| • HTTP client wrapping Game Server API
• Sends YEN positions and receives bot moves
• Uses SharedContracts DTOs (YenPositionDto, YenMoveDto)
|===

==== White Box: Game Server

[plantuml, level2-gameserver, png]
----
@startuml
package "Game Server (Rust)" {

  component [EngineService] <<RUST>> #LightBlue
  component [NextMoveComputer] <<RUST>> #LightYellow
  component [WinEvaluator] <<RUST>> #LightYellow

  interface "Strategy" as IStrategy <<interface>>
  component [RandomStrategy] <<RUST>> #LightGreen
  component [HeuristicStrategy] <<RUST>> #LightGreen

  package "GameDomain" <<frame>> {
    component [Game] <<RUST>>
    component [Board] <<RUST>>
    component [Move] <<RUST>>
    component [Player] <<RUST>>
    component [Coordinate] <<RUST>>
    component [WinChecker] <<RUST>>
  }
}

[EngineService] ..> [NextMoveComputer] : uses
[EngineService] ..> [WinEvaluator] : uses

[NextMoveComputer] ..> IStrategy : delegates to
[WinEvaluator] ..> [Game] : evaluates

IStrategy <|.. [RandomStrategy]
IStrategy <|.. [HeuristicStrategy]

[Game] *-- [Board]
[Game] *-- [Move]
[Game] *-- [Player]
[Board] *-- [Coordinate]
[Game] ..> [WinChecker]

note right of IStrategy
  **Strategy Pattern**
  Enables multiple bot
  implementations with
  different difficulty levels
end note

note bottom of GameDomain
  **Domain-Driven Design**
  Pure game logic with no
  external dependencies
end note

@enduml
----

**Motivation:**

The Game Server encapsulates all game-specific logic using Domain-Driven Design principles. The Strategy pattern allows for extensible bot implementations without modifying core game logic.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **EngineService**
a| • REST API entry point (`POST /ybot/choose/{botId}`)
• Parses YEN notation from requests
• Delegates to NextMoveComputer or WinEvaluator
• Returns YenMoveDto responses

| **NextMoveComputer**
a| • Computes next optimal move for a given bot strategy
• Selects appropriate Strategy implementation based on botId/difficulty
• Returns valid move in YEN notation

| **WinEvaluator**
a| • Checks if game has ended (win condition met)
• Analyzes board for Y-connections (3-sided paths)
• Returns game status (ongoing/won/draw)

| **Strategy Interface**
a| • Defines contract for bot implementations
• `compute_move(board: &Board, difficulty: u8) -> Move`

| **RandomStrategy**
a| • Implements random valid move selection
• Low difficulty, fast execution
• Used for testing and beginner difficulty

| **HeuristicStrategy**
a| • Implements heuristic-based move evaluation
• Considers board control, connection potential, blocking opponent
• Configurable difficulty levels affect search depth

| **GameDomain Package**
a| • **Game**: Aggregates board, players, move history, game state
• **Board**: Hexagonal grid representation using barycentric coordinates
• **Move**: Represents player action (position + player)
• **Player**: Entity representing B or R player
• **Coordinate**: Barycentric coordinate (x, y, z)
• **WinChecker**: Algorithm to detect Y-shaped winning connections
|===

==== White Box: UsersService

[plantuml, level2-users, png]
----
@startuml
package "UsersService (Node.js + TypeScript)" {

  package "Controllers" <<frame>> {
    component [UsersApiController] <<TS>>
  }

  package "Services" <<frame>> {
    component [AuthService] <<TS>>
    component [UserService] <<TS>>
    component [MatchService] <<TS>>
    component [StatsService] <<TS>>
  }

  package "Repositories" <<frame>> {
    component [UserRepository] <<TS>>
    component [MatchRepository] <<TS>>
    component [StatsRepository] <<TS>>
  }
}

database "SQLite DB" as db <<database>>

[UsersApiController] ..> [AuthService]
[UsersApiController] ..> [UserService]
[UsersApiController] ..> [MatchService]
[UsersApiController] ..> [StatsService]

[AuthService] ..> [UserRepository]
[UserService] ..> [UserRepository]
[MatchService] ..> [MatchRepository]
[StatsService] ..> [StatsRepository]

[UserRepository] --> db
[MatchRepository] --> db
[StatsRepository] --> db

note right of [MatchRepository]
  **Repository Pattern**
  Abstracts database access
  Enables testing with mocks
end note

@enduml
----

**Motivation:**

UsersService follows a clean architecture with Repository pattern for database abstraction. This service is the source of truth for user data and match state persistence.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **UsersApiController**
a| • Exposes internal REST API for Web App Server
• Endpoints: `/auth/*`, `/users/*`, `/matches/*`, `/stats/*`
• Input validation and error handling

| **AuthService**
a| • User registration and authentication logic
• Password hashing (Argon2)
• JWT token generation and validation

| **UserService**
a| • CRUD operations for user accounts
• User profile management

| **MatchService**
a| • Match creation and state persistence
• Stores match metadata (size, strategy, difficulty, participants)
• Updates match status (ongoing/finished)

| **StatsService**
a| • Aggregates player statistics (wins/losses/draws)
• Calculates rankings and metrics
• Provides historical match data

| **UserRepository**
a| • Database access layer for `users` table
• SQL query execution and result mapping

| **MatchRepository**
a| • Database access layer for `matches` table
• Stores serialized YEN board states

| **StatsRepository**
a| • Database access layer for aggregated statistics
• Optimized read queries for rankings
|===
