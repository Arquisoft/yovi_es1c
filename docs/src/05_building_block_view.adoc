ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]
== Building Block View

=== Whitebox Overall System

==== Overview Diagram

[plantuml, level1-overview, png]
----
@startuml
!include <C4/C4_Component>

skinparam componentStyle rectangle

actor "User" as user

package "Yovi System" {
  component "Nginx\n(API Gateway)" as nginx <<reverse proxy>>
  component "React Frontend\n(Webapp)\n(Vite + TS)" as frontend <<application>>
  component "Auth Service\n(Node.js + Express + TS)" as auth <<service>>
  component "Users Service\n(Node.js + Express + TS)" as users <<service>>
  component "Game Service\n(Node.js + Express + TS)" as gameservice <<service>>
  component "Game Server\n(Rust)" as gamey <<service>>
  database "auth.db\n(SQLite)" as authdb <<database>>
  database "users.db\n(SQLite)" as usersdb <<database>>
  database "game.db\n(SQLite)" as gamedb <<database>>
}

user -down-> nginx : HTTP (80)\nREST/JSON
nginx -down-> frontend : Serve static files
nginx -down-> auth : HTTP (3001)\n/api/auth/*
nginx -down-> users : HTTP (3000)\n/api/users/*
nginx -down-> gameservice : HTTP (3002)\n/api/game/*
nginx -down-> gamey : HTTP (4000)\n/api/gamey/*

frontend ..> nginx : API calls from browser\n(/api/auth/*, /api/users/*, /api/game/*, /api/gamey/*)

auth -down-> authdb : SQLite\nSQL
users -down-> usersdb : SQLite\nSQL
gameservice -down-> gamedb : SQLite\nSQL

note right of nginx
  **API Gateway**
  Single entry point
  Routes all requests
  Rate limiting, CORS
end note

note right of auth
  **Auth Layer**
  Registration & login
  JWT management
  Credentials (auth.db)
end note

note right of users
  **Profile Layer**
  User profile management
  Profile data (users.db)
end note

note right of gameservice
  **Game Data Layer**
  Match & stats persistence
  Game data (game.db)
end note

note right of gamey
  **Core Game Engine**
  Stateless game logic
  Move validation & bot AI
end note

@enduml
----

**Motivation:**

The Yovi system is decomposed into five main subsystems to achieve separation of concerns, independent scalability, technology-specific optimization, and fault isolation across data domains:

* **Nginx (API Gateway)**: Single public entry point for all requests, handling routing, rate limiting, and CORS
* **React Frontend (Webapp)**: User interface layer running in the browser, managing UI state and coordinating API calls to backend services
* **Auth Service**: Authentication layer with exclusive access to `auth.db`, managing credentials, registration, login, and JWT tokens
* **Users Service**: Profile layer with exclusive access to `users.db`, managing user profile data
* **Game Service**: Game data layer with exclusive access to `game.db`, managing match persistence, move history, and statistics
* **Game Server**: Pure game logic engine optimized for performance (Rust), completely stateless

Each service owns its own database. A failure or overload in one database does not propagate to the others, achieving fault isolation at the data layer.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Building Block | Responsibility

| **Nginx (API Gateway)**
a| • Single public entry point on port 80
• Routes requests based on URL paths:
** `/api/auth/*` → Auth Service (port 3001)
** `/api/users/*` → Users Service (port 3000)
** `/api/game/*` → Game Service (port 3002)
** `/api/gamey/*` → Game Server (port 4000)
** `/*` → React Frontend static files
• Handles CORS and rate limiting
• Serves React frontend static files
• Isolates backend services from direct external access

| **React Frontend (Webapp)**
a| • Single-page application (SPA) running in user's browser
• Renders game board and UI components using React
• Handles user interactions (login, game moves, statistics viewing)
• Manages client-side state (game state, user session)
• Makes HTTP API calls to all backend services through Nginx
• Coordinates game flow from the client side

| **Auth Service**
a| • Single point of access to `auth.db`
• Manages user registration and login
• Password hashing (bcrypt/Argon2)
• JWT token generation and validation
• Token refresh logic
• Exposes REST API on port 3001 (internal)

| **Users Service**
a| • Single point of access to `users.db`
• Manages user profile data (username, avatar, preferences)
• Handles user CRUD operations
• Provides user search and retrieval
• Exposes REST API on port 3000 (internal)

| **Game Service**
a| • Single point of access to `game.db`
• Manages match lifecycle (creation, updates, completion)
• Persists move history and serialized YEN board states
• Aggregates and provides player statistics and rankings
• Exposes REST API on port 3002 (internal)

| **Game Server (Rust)**
a| • Implements core Y game rules and logic
• Validates moves and checks win conditions
• Computes bot moves using various strategies (random, heuristic)
• Completely stateless service using YEN notation
• Exposes REST API on port 4000 (internal)
• No database access, pure computation

| **auth.db (SQLite)**
a| • Stores user credentials (hashed passwords)
• Persists JWT token metadata and refresh tokens
• Accessible only through Auth Service
• Isolated from profile and game data

| **users.db (SQLite)**
a| • Stores user profile information (username, avatar, preferences)
• Accessible only through Users Service
• Isolated from credentials and game data

| **game.db (SQLite)**
a| • Stores match records and metadata (size, strategy, difficulty, status)
• Persists move history and serialized YEN board states
• Maintains player statistics and rankings
• Accessible only through Game Service
• Isolated from credentials and profile data
|===

**Important Interfaces:**

* **User → Nginx**: HTTP REST API (port 80, public)
* **Nginx → React Frontend**: Static file serving (HTML, JS, CSS)
* **Nginx → Auth Service**: REST API (`/api/auth/*`, port 3001, internal)
* **Nginx → Users Service**: REST API (`/api/users/*`, port 3000, internal)
* **Nginx → Game Service**: REST API (`/api/game/*`, port 3002, internal)
* **Nginx → Game Server**: REST API (`/api/gamey/*`, port 4000, internal)
* **React Frontend → Nginx**: AJAX/Fetch API calls from browser
* **Auth Service → auth.db**: SQLite native SQL queries
* **Users Service → users.db**: SQLite native SQL queries
* **Game Service → game.db**: SQLite native SQL queries

**Communication Flow Example:**

1. User loads the app → Nginx serves React static files → React runs in browser
2. User clicks "Login" → React calls `POST /api/auth/login` → Nginx routes to Auth Service
3. Auth Service validates credentials against `auth.db` → Returns JWT token
4. User creates a match → React calls `POST /api/game/matches` → Nginx routes to Game Service → persisted in `game.db`
5. User makes a move → React calls `POST /api/gamey/play` → Nginx routes to Game Server → returns updated YEN
6. Game Server returns move validation → React calls `POST /api/game/matches/{id}/moves` → Game Service persists in `game.db`
7. React updates UI

=== Level 2

==== White Box: Auth Service

[plantuml, level2-auth, png]
----
@startuml
package "Auth Service (Node.js + TypeScript)" {

  package "Controllers" <<frame>> {
    component [AuthController] <<TS>>
  }

  package "Services" <<frame>> {
    component [AuthService] <<TS>>
  }

  package "Repositories" <<frame>> {
    component [CredentialsRepository] <<TS>>
  }
}

database "auth.db (SQLite)" as authdb <<database>>

[AuthController] ..> [AuthService]
[AuthService] ..> [CredentialsRepository]
[CredentialsRepository] --> authdb

note right of [AuthController]
  **Endpoints:**
  POST /api/auth/register
  POST /api/auth/login
  POST /api/auth/refresh
end note

note right of [AuthService]
  **Business Logic:**
  Password hashing (bcrypt/Argon2)
  JWT generation & validation
  Token refresh
end note

note right of [CredentialsRepository]
  **Repository Pattern**
  Abstracts auth.db access
  Enables testing with mocks
end note

@enduml
----

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **AuthController**
a| • Exposes REST API endpoints: `POST /api/auth/register`, `POST /api/auth/login`, `POST /api/auth/refresh`
• Input validation and error handling
• Request/response mapping

| **AuthService**
a| • User registration logic
• Password hashing and verification (bcrypt/Argon2)
• JWT token generation and validation
• Token refresh logic

| **CredentialsRepository**
a| • Database access layer for `auth.db`
• SQL query execution and result mapping
• Stores hashed passwords and token metadata
|===

==== White Box: Users Service

[plantuml, level2-users, png]
----
@startuml
package "Users Service (Node.js + TypeScript)" {

  package "Controllers" <<frame>> {
    component [UsersController] <<TS>>
  }

  package "Services" <<frame>> {
    component [UserService] <<TS>>
  }

  package "Repositories" <<frame>> {
    component [UserRepository] <<TS>>
  }
}

database "users.db (SQLite)" as usersdb <<database>>

[UsersController] ..> [UserService]
[UserService] ..> [UserRepository]
[UserRepository] --> usersdb

note right of [UsersController]
  **Endpoints:**
  GET /api/users/{id}
  PUT /api/users/{id}
  GET /api/users (search)
end note

note right of [UserService]
  **Business Logic:**
  Profile management
  User CRUD
end note

note right of [UserRepository]
  **Repository Pattern**
  Abstracts users.db access
  Enables testing with mocks
end note

@enduml
----

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **UsersController**
a| • Exposes REST API endpoints: `GET /api/users/{id}`, `PUT /api/users/{id}`, `GET /api/users`
• Input validation and authentication middleware (JWT verification via Auth Service)
• Request/response mapping

| **UserService**
a| • CRUD operations for user profiles
• User search and retrieval
• Profile validation logic

| **UserRepository**
a| • Database access layer for `users.db`
• SQL query execution and result mapping
• Transaction management for profile operations
|===

==== White Box: Game Service

[plantuml, level2-gameservice, png]
----
@startuml
package "Game Service (Node.js + TypeScript)" {

  package "Controllers" <<frame>> {
    component [GameController] <<TS>>
  }

  package "Services" <<frame>> {
    component [MatchService] <<TS>>
    component [StatsService] <<TS>>
  }

  package "Repositories" <<frame>> {
    component [MatchRepository] <<TS>>
    component [StatsRepository] <<TS>>
  }
}

database "game.db (SQLite)" as gamedb <<database>>

[GameController] ..> [MatchService]
[GameController] ..> [StatsService]
[MatchService] ..> [MatchRepository]
[StatsService] ..> [StatsRepository]
[MatchRepository] --> gamedb
[StatsRepository] --> gamedb

note right of [GameController]
  **Endpoints:**
  POST /api/game/matches
  GET /api/game/matches/{id}
  POST /api/game/matches/{id}/moves
  GET /api/game/stats/{userId}
end note

note right of [MatchService]
  **Business Logic:**
  Match lifecycle management
  Move history persistence
  YEN board state storage
end note

note right of [StatsRepository]
  **Repository Pattern**
  Abstracts game.db access
  Enables testing with mocks
  Single point of game DB access
end note

@enduml
----

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **GameController**
a| • Exposes REST API endpoints for match and stats operations
• Endpoints: `POST /api/game/matches`, `GET /api/game/matches/{id}`, `POST /api/game/matches/{id}/moves`, `GET /api/game/stats/{userId}`
• Input validation and authentication middleware (JWT verification)
• Request/response mapping

| **MatchService**
a| • Match creation and lifecycle management
• Stores match metadata (size, strategy, difficulty, participants)
• Updates match status (ongoing/finished)
• Persists serialized YEN board states and move history
• Match history queries

| **StatsService**
a| • Aggregates player statistics (wins/losses/draws)
• Calculates rankings and metrics
• Provides historical match data
• Win rate calculations

| **MatchRepository**
a| • Database access layer for matches in `game.db`
• Stores serialized YEN board states
• Query optimization for match history
• Match outcome persistence

| **StatsRepository**
a| • Database access layer for statistics in `game.db`
• Optimized read queries for rankings
• Computed statistics and performance metrics
|===

==== White Box: Game Server

[plantuml, level2-gameserver, png]
----
@startuml
package "Game Server (Rust)" {

  component [EngineService] <<RUST>> #LightBlue
  component [NextMoveComputer] <<RUST>> #LightYellow
  component [WinEvaluator] <<RUST>> #LightYellow

  interface "Strategy" as IStrategy <<interface>>
  component [RandomStrategy] <<RUST>> #LightGreen
  component [HeuristicStrategy] <<RUST>> #LightGreen

  package "GameDomain" <<frame>> {
    component [Game] <<RUST>>
    component [Board] <<RUST>>
    component [Move] <<RUST>>
    component [Player] <<RUST>>
    component [Coordinate] <<RUST>>
    component [WinChecker] <<RUST>>
  }
}

[EngineService] ..> [NextMoveComputer] : uses
[EngineService] ..> [WinEvaluator] : uses

[NextMoveComputer] ..> IStrategy : delegates to
[WinEvaluator] ..> [Game] : evaluates

IStrategy <|.. [RandomStrategy]
IStrategy <|.. [HeuristicStrategy]

[Game] *-- [Board]
[Game] *-- [Move]
[Game] *-- [Player]
[Board] *-- [Coordinate]
[Game] ..> [WinChecker]

note right of IStrategy
  **Strategy Pattern**
  Enables multiple bot
  implementations with
  different difficulty levels
end note

note bottom of GameDomain
  **Domain-Driven Design**
  Pure game logic with no
  external dependencies
end note

@enduml
----

**Motivation:**

The Game Server encapsulates all game-specific logic using Domain-Driven Design principles. The Strategy pattern allows for extensible bot implementations without modifying core game logic. This service is completely stateless and has no database dependencies. All persistence is delegated to the Game Service.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **EngineService**
a| • REST API entry point (`POST /api/gamey/play`, `POST /api/gamey/ybot/choose/{botId}`)
• Parses YEN notation from requests
• Delegates to NextMoveComputer or WinEvaluator
• Returns YenMoveDto responses
• Stateless request handling

| **NextMoveComputer**
a| • Computes next optimal move for a given bot strategy
• Selects appropriate Strategy implementation based on botId/difficulty
• Returns valid move in YEN notation
• No side effects, pure computation

| **WinEvaluator**
a| • Checks if game has ended (win condition met)
• Analyzes board for Y-connections (3-sided paths)
• Returns game status (ongoing/won/draw)
• Deterministic evaluation

| **Strategy Interface**
a| • Defines contract for bot implementations
• `compute_move(board: &Board, difficulty: u8) -> Move`
• Enables extensibility for new strategies

| **RandomStrategy**
a| • Implements random valid move selection
• Low difficulty, fast execution
• Used for testing and beginner difficulty
• No lookahead or evaluation

| **HeuristicStrategy**
a| • Implements heuristic-based move evaluation
• Considers board control, connection potential, blocking opponent
• Configurable difficulty levels affect search depth
• Position evaluation function

| **GameDomain Package**
a| • **Game**: Aggregates board, players, move history, game state
• **Board**: Hexagonal grid representation using barycentric coordinates
• **Move**: Represents player action (position + player)
• **Player**: Entity representing B or R player
• **Coordinate**: Barycentric coordinate (x, y, z)
• **WinChecker**: Algorithm to detect Y-shaped winning connections
|===
