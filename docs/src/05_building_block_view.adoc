ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]
== Building Block View

=== Whitebox Overall System

==== Overview Diagram

[plantuml, level1-overview, png]
----
@startuml
!include <C4/C4_Component>

skinparam componentStyle rectangle

actor "User" as user

package "Yovi System" {
  component "Nginx\n(API Gateway)" as nginx <<reverse proxy>>
  component "React Frontend\n(Webapp)\n(Vite + TS)" as frontend <<application>>
  component "Users Service\n(Node.js + Express + TS)" as users <<service>>
  component "Game Server\n(Rust)" as gamey <<service>>
  database "SQLite Database" as db <<database>>
}

user -down-> nginx : HTTP (80)\nREST/JSON
nginx -down-> frontend : Serve static files
nginx -down-> users : HTTP (3000)\n/api/users/*
nginx -down-> gamey : HTTP (4000)\n/api/gamey/*

frontend ..> nginx : API calls from browser\n(/api/users/*, /api/gamey/*)

users -down-> db : SQLite\nSQL

note right of nginx
  **API Gateway**
  Single entry point
  Routes all requests
  Rate limiting, CORS
end note

note right of frontend
  **React SPA**
  Runs in browser
  Calls Users & Gamey APIs
  Game UI & state management
end note

note right of users
  **Data Layer**
  Single DB access point
  Auth, matches, statistics
end note

note right of gamey
  **Core Game Engine**
  Stateless game logic
  Move validation & bot AI
end note

@enduml
----

**Motivation:**

The Yovi system is decomposed into four main subsystems to achieve separation of concerns, independent scalability, and technology-specific optimization:

* **Nginx (API Gateway)**: Single public entry point for all requests, handling routing, rate limiting, and CORS
* **React Frontend (Webapp)**: User interface layer running in the browser, managing UI state and coordinating API calls to backend services
* **Users Service**: Data layer with exclusive database access, managing authentication, users, matches, and statistics
* **Game Server**: Pure game logic engine optimized for performance (Rust)
* **Database**: Persistent storage accessible only through Users Service

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Building Block | Responsibility

| **Nginx (API Gateway)**
a| • Single public entry point on port 80
• Routes requests based on URL paths (`/api/users/*`, `/api/gamey/*`, `/*`)
• Handles CORS and rate limiting
• Serves React frontend static files
• Isolates backend services from direct external access

| **React Frontend (Webapp)**
a| • Single-page application (SPA) running in user's browser
• Renders game board and UI components using React
• Handles user interactions (login, game moves, statistics viewing)
• Manages client-side state (game state, user session)
• Makes HTTP API calls to Users Service and Game Server through Nginx
• Coordinates game flow from the client side

| **Users Service**
a| • Single point of access to the database
• Manages user authentication and authorization (JWT tokens)
• Handles user CRUD operations
• Persists match history and game state
• Provides player statistics and rankings
• Ensures data consistency and integrity
• Exposes REST API on port 3000 (internal)

| **Game Server**
a| • Implements core Y game rules and logic
• Validates moves and checks win conditions
• Computes bot moves using various strategies (random, heuristic)
• Stateless service using YEN notation
• Exposes REST API on port 4000 (internal)
• No database access, pure computation

| **Database (SQLite)**
a| • Stores user accounts and credentials
• Persists match history and game state
• Maintains player statistics and rankings
• Accessible only through Users Service
• Embedded database (no separate server process)
|===

**Important Interfaces:**

* **User → Nginx**: HTTP REST API (port 80, public)
* **Nginx → React Frontend**: Static file serving (HTML, JS, CSS)
* **Nginx → Users Service**: REST API (`/api/users/*`, port 3000, internal)
* **Nginx → Game Server**: REST API (`/api/gamey/*`, port 4000, internal)
* **React Frontend → Nginx**: AJAX/Fetch API calls from browser (`/api/users/*`, `/api/gamey/*`)
* **Users Service → Database**: SQLite native SQL queries

**Communication Flow Example:**

1. User loads the app → Nginx serves React static files → React runs in browser
2. User clicks "Login" → React calls `POST /api/users/auth/login` → Nginx routes to Users Service
3. User makes a move → React calls `POST /api/gamey/play` → Nginx routes to Game Server
4. Game Server returns move validation → React updates UI

=== Level 2

==== White Box: Users Service

[plantuml, level2-users, png]
----
@startuml
package "Users Service (Node.js + TypeScript)" {

  package "Controllers" <<frame>> {
    component [UsersApiController] <<TS>>
  }

  package "Services" <<frame>> {
    component [AuthService] <<TS>>
    component [UserService] <<TS>>
    component [MatchService] <<TS>>
    component [StatsService] <<TS>>
  }

  package "Repositories" <<frame>> {
    component [UserRepository] <<TS>>
    component [MatchRepository] <<TS>>
    component [StatsRepository] <<TS>>
  }
}

database "SQLite DB" as db <<database>>

[UsersApiController] ..> [AuthService]
[UsersApiController] ..> [UserService]
[UsersApiController] ..> [MatchService]
[UsersApiController] ..> [StatsService]

[AuthService] ..> [UserRepository]
[UserService] ..> [UserRepository]
[MatchService] ..> [MatchRepository]
[StatsService] ..> [StatsRepository]

[UserRepository] --> db
[MatchRepository] --> db
[StatsRepository] --> db

note right of [MatchRepository]
  **Repository Pattern**
  Abstracts database access
  Enables testing with mocks
  Single point of DB access
end note

@enduml
----

**Motivation:**

Users Service follows a clean architecture with Repository pattern for database abstraction. This service is the single source of truth for user data and match state persistence. No other service has direct database access.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **UsersApiController**
a| • Exposes REST API endpoints for Nginx and clients
• Endpoints: `/auth/*`, `/users/*`, `/matches/*`, `/stats/*`
• Input validation and error handling
• Authentication middleware (JWT verification)
• Request/response mapping

| **AuthService**
a| • User registration and authentication logic
• Password hashing (bcrypt or Argon2)
• JWT token generation and validation
• Session management
• Token refresh logic

| **UserService**
a| • CRUD operations for user accounts
• User profile management
• User search and retrieval
• Account validation

| **MatchService**
a| • Match creation and state persistence
• Stores match metadata (size, strategy, difficulty, participants)
• Updates match status (ongoing/finished)
• Stores serialized YEN board states
• Match history queries

| **StatsService**
a| • Aggregates player statistics (wins/losses/draws)
• Calculates rankings and metrics
• Provides historical match data
• Optimized queries for leaderboards
• Win rate calculations

| **UserRepository**
a| • Database access layer for `users` table
• SQL query execution and result mapping
• Transaction management for user operations
• Password hash storage

| **MatchRepository**
a| • Database access layer for `matches` table
• Stores serialized YEN board states
• Query optimization for match history
• Match outcome persistence

| **StatsRepository**
a| • Database access layer for aggregated statistics
• Optimized read queries for rankings
• Computed statistics caching
• Performance metrics
|===

==== White Box: Game Server

[plantuml, level2-gameserver, png]
----
@startuml
package "Game Server (Rust)" {

  component [EngineService] <<RUST>> #LightBlue
  component [NextMoveComputer] <<RUST>> #LightYellow
  component [WinEvaluator] <<RUST>> #LightYellow

  interface "Strategy" as IStrategy <<interface>>
  component [RandomStrategy] <<RUST>> #LightGreen
  component [HeuristicStrategy] <<RUST>> #LightGreen

  package "GameDomain" <<frame>> {
    component [Game] <<RUST>>
    component [Board] <<RUST>>
    component [Move] <<RUST>>
    component [Player] <<RUST>>
    component [Coordinate] <<RUST>>
    component [WinChecker] <<RUST>>
  }
}

[EngineService] ..> [NextMoveComputer] : uses
[EngineService] ..> [WinEvaluator] : uses

[NextMoveComputer] ..> IStrategy : delegates to
[WinEvaluator] ..> [Game] : evaluates

IStrategy <|.. [RandomStrategy]
IStrategy <|.. [HeuristicStrategy]

[Game] *-- [Board]
[Game] *-- [Move]
[Game] *-- [Player]
[Board] *-- [Coordinate]
[Game] ..> [WinChecker]

note right of IStrategy
  **Strategy Pattern**
  Enables multiple bot
  implementations with
  different difficulty levels
end note

note bottom of GameDomain
  **Domain-Driven Design**
  Pure game logic with no
  external dependencies
end note

@enduml
----

**Motivation:**

The Game Server encapsulates all game-specific logic using Domain-Driven Design principles. The Strategy pattern allows for extensible bot implementations without modifying core game logic. This service is completely stateless and has no database dependencies.

**Contained Building Blocks:**

[cols="1,3", options="header"]
|===
| Component | Responsibility

| **EngineService**
a| • REST API entry point (`POST /api/gamey/play`, `POST /api/gamey/ybot/choose/{botId}`)
• Parses YEN notation from requests
• Delegates to NextMoveComputer or WinEvaluator
• Returns YenMoveDto responses
• Stateless request handling

| **NextMoveComputer**
a| • Computes next optimal move for a given bot strategy
• Selects appropriate Strategy implementation based on botId/difficulty
• Returns valid move in YEN notation
• No side effects, pure computation

| **WinEvaluator**
a| • Checks if game has ended (win condition met)
• Analyzes board for Y-connections (3-sided paths)
• Returns game status (ongoing/won/draw)
• Deterministic evaluation

| **Strategy Interface**
a| • Defines contract for bot implementations
• `compute_move(board: &Board, difficulty: u8) -> Move`
• Enables extensibility for new strategies

| **RandomStrategy**
a| • Implements random valid move selection
• Low difficulty, fast execution
• Used for testing and beginner difficulty
• No lookahead or evaluation

| **HeuristicStrategy**
a| • Implements heuristic-based move evaluation
• Considers board control, connection potential, blocking opponent
• Configurable difficulty levels affect search depth
• Position evaluation function

| **GameDomain Package**
a| • **Game**: Aggregates board, players, move history, game state
• **Board**: Hexagonal grid representation using barycentric coordinates
• **Move**: Represents player action (position + player)
• **Player**: Entity representing B or R player
• **Coordinate**: Barycentric coordinate (x, y, z)
• **WinChecker**: Algorithm to detect Y-shaped winning connections
|===
