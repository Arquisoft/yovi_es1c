[[section-runtime-view]]
== Runtime View

This section describes how the main components of the YOVI system collaborate at runtime to support user authentication, match management, gameplay, bot interaction, and statistics retrieval.
The scenarios below are derived directly from the systemâ€™s architecture and message flows, using JSON/YEN as the canonical representation of game states.

=== 6.1. Runtime Scenario 1: User Registration and Login

This scenario shows how a human user registers or logs into the system through the Web Frontend.
The WebApp BFF delegates authentication to the UsersService, which persists user data in SQLite.

[plantuml, "runtime-login", png]
----
actor "Web Frontend" as Human
participant "WebApp BFF\n(TS API)" as Api
participant "UsersService\n(TS API)" as Users
database "SQLite DB" as DB

Human -> Api: POST /auth/register | /auth/login
Api -> Users: POST /auth/register | /auth/login
Users -> DB: create/read user
DB --> Users: user + credentials
Users --> Api: token/session
Api --> Human: token/session
----

*Notable Aspects:*

- Authentication is centralized in the UsersService.
- The BFF does not store credentials; it only forwards tokens.
- SQLite acts as the single source of truth for user accounts.

=== 6.2. Runtime Scenario 2: Authorization Check

When a user requests protected resources, the BFF verifies the token either locally (JWT) or by delegating to the UsersService.

[plantuml, "runtime-auth-check", png]
----
actor Human
participant Api
participant Users

Human -> Api: GET /matches
Api -> Users: GET /auth/verify (token)
Users --> Api: 401 Unauthorized
Api --> Human: 401 Unauthorized
----

*Notable Aspects:*

- Ensures that only authenticated users can access match data.
- Supports both JWT local validation and remote verification.

=== 6.3. Runtime Scenario 3: Match Creation and Initial State Retrieval

A user creates a new match by specifying board size, strategy, and difficulty.
The UsersService persists the match and returns the initial YEN state.

[plantuml, "runtime-create-match", png]
----
actor Human
participant Api
participant Users
database DB

Human -> Api: POST /matches (size, strategy, difficulty)
Api -> Users: POST /matches (userId, size, strategy, difficulty)
Users -> DB: create match
DB --> Users: matchId + persisted state
Users --> Api: match + initial YEN
Api --> Human: match + initial YEN
----

*Notable Aspects:*

- The UsersService owns match lifecycle and persistence.
- Initial game state is always stored and returned in YEN format.

=== 6.4. Runtime Scenario 4: Player Move (Human Turn)

The human player submits a move in YEN notation.
The BFF retrieves the current match state, validates it, calls the Rust engine for the bot move, and persists the updated state.

[plantuml, "runtime-human-move", png]
----
actor Human
participant Api
participant Users
participant "Game Server\n(Rust)" as Engine
database DB

Human -> Api: POST /play (matchId, position=YEN, strategy, difficulty)

' 1) Validate and retrieve match state
Api -> Users: GET /matches/{matchId}
Users -> DB: read match + status
DB --> Users: match state/status
Users --> Api: match state/status

alt match finished
  Api --> Human: 409 game finished
end

' 2) Compute bot move
Api -> Engine: POST /ybot/choose/{botId} (position + params)
Engine --> Api: YenMoveDto + status

alt invalid YEN
  Api --> Human: 400 invalid position
end

' 3) Persist updated state
Api -> Users: POST /matches/{matchId}/moves (YenMoveDto + updatedYen + status)
Users -> DB: persist move/result/stats
DB --> Users: ok + updated aggregates
Users --> Api: updated match + stats snapshot
Api --> Human: move + updated YEN
----

*Notable Aspects:*

- UsersService is the authoritative source of match state.
- The Rust engine is stateless and only computes moves.
- All updates are persisted atomically in SQLite.

=== 6.5. Runtime Scenario 5: Bot API Interaction

Bots can play matches programmatically using the external API.
The flow mirrors the human move scenario but uses bot credentials or API keys.

[plantuml, "runtime-bot-api", png]
----
actor "Bot Client" as Bot
participant Api
participant Users
participant Engine
database DB

Bot -> Api: POST /bot/play (matchId, position=YEN, strategy, difficulty)

Api -> Users: GET /matches/{matchId} (auth/botKey)
Users -> DB: read match + status
DB --> Users: match state/status
Users --> Api: match state/status

Api -> Engine: POST /ybot/choose/{botId}
Engine --> Api: YenMoveDto + status

Api -> Users: POST /matches/{matchId}/moves (move + updated state)
Users -> DB: persist move/result/stats
DB --> Users: ok
Users --> Api: ok

Api --> Bot: move + updated YEN
----

*Notable Aspects:*

- Bots interact with the same engine and match logic as human players.
- API keys or bot credentials ensure secure automated access.

=== 6.6. Runtime Scenario 6: Statistics and History Retrieval

Users can request aggregated statistics such as number of matches, wins/losses, and performance metrics.

[plantuml, "runtime-stats", png]
----
actor Human
participant Api
participant Users
database DB

Human -> Api: GET /stats
Api -> Users: GET /stats (userId)
Users -> DB: read stats/history
DB --> Users: stats/history
Users --> Api: StatsDto
Api --> Human: StatsDto
----

*Notable Aspects:*

- Statistics are computed from persisted match data.
- The UsersService exposes a unified Stats API for both frontend and bots.
