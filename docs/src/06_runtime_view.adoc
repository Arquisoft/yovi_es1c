[[section-runtime-view]]
== Runtime View

This section describes how the main components of the YOVI system collaborate at runtime to support user authentication, match management, gameplay, bot interaction, and statistics retrieval.
The scenarios below are derived directly from the system's architecture and message flows, using JSON/YEN as the canonical representation of game states.

All communication between the React Frontend (running in the user's browser) and backend services goes through the Nginx API Gateway, which routes requests to the appropriate service based on URL paths.

=== Runtime Scenario 1: User Registration and Login

This scenario shows how a human user registers or logs into the system through the React Frontend.
The frontend makes API calls through Nginx, which routes authentication requests to the Auth Service, which persists credential data in `auth.db`.

[plantuml, "runtime-login", png]
----
actor "User (Browser)" as Human
participant "React Frontend" as Frontend
participant "Nginx\n(API Gateway)" as Nginx
participant "Auth Service\n(Node.js)" as Auth
database "auth.db" as AuthDB

Human -> Frontend: Click Login/Register
Frontend -> Nginx: POST /api/auth/register | /api/auth/login
Nginx -> Auth: Forward to port 3001
Auth -> AuthDB: create/read user credentials
AuthDB --> Auth: credentials record
Auth --> Nginx: token/session (JWT)
Nginx --> Frontend: token/session
Frontend --> Human: Display success, store token
----

*Notable Aspects:*

- Authentication is fully isolated in the Auth Service and its dedicated `auth.db`
- Nginx routes all `/api/auth/*` requests to Auth Service (port 3001)
- React Frontend stores the JWT token (localStorage or sessionStorage)
- `auth.db` acts as the single source of truth for credentials
- A failure in other databases (`users.db`, `game.db`) does not affect the login flow

=== Runtime Scenario 2: Authorization Check

When a user requests protected resources, the React Frontend includes the JWT token in the request headers.
Nginx forwards the request to the appropriate service, which delegates JWT verification to Auth Service through an internal call to `/api/auth/verify`.

[plantuml, "runtime-auth-check", png]
----
actor "User (Browser)" as Human
participant "React Frontend" as Frontend
participant "Nginx" as Nginx
participant "Auth Service" as Auth
participant "Game Service" as GameService

Human -> Frontend: Request matches page
Frontend -> Nginx: GET /api/game/matches\nAuthorization: Bearer <token>
Nginx -> GameService: Forward with auth header
GameService -> Auth: Verify JWT token\n(internal call)

alt invalid token
  Auth --> GameService: 401 Unauthorized
  GameService --> Nginx: 401 Unauthorized
  Nginx --> Frontend: 401 Unauthorized
  Frontend --> Human: Redirect to login
else valid token
  Auth --> GameService: 200 OK (token valid)
  GameService --> Nginx: 200 + matches data
  Nginx --> Frontend: 200 + matches data
  Frontend --> Human: Display matches
end
----

*Notable Aspects:*

- JWT validation is responsibility of the Auth Service
- Other services (Game Service, Users Service) delegate token verification to Auth Service via internal call
- React Frontend handles unauthorized responses by redirecting to login
- Nginx simply routes requests without authentication logic

Verify endpoint contract used by internal services:

- Method and path: `POST /api/auth/verify`
- Required header: `Authorization: Bearer <token>`
- Success response (`200`): `{ "userId": "<sub claim>" }`
- Error response (`401`): `{ "error": "Unauthorized" }` for missing, malformed, invalid, or expired tokens
- Security boundary: `/api/auth/verify` must not be exposed publicly through Nginx and should be consumed only over internal service-to-service network calls

=== Runtime Scenario 3: Match Creation and Initial State Retrieval

A user creates a new match by specifying board size, strategy, and difficulty through the React UI.
The Game Service persists the match in `game.db` and returns the initial YEN state.

[plantuml, "runtime-create-match", png]
----
actor "User (Browser)" as Human
participant "React Frontend" as Frontend
participant "Nginx" as Nginx
participant "Auth Service" as Auth
participant "Game Service\n(Node.js)" as GameService
database "game.db" as GameDB

Human -> Frontend: Fill match form\n(size, strategy, difficulty)
Frontend -> Nginx: POST /api/game/matches\n{size, strategy, difficulty, userId}\nAuthorization: Bearer <token>
Nginx -> GameService: Forward to port 3002
GameService -> Auth: Verify JWT token
Auth --> GameService: 200 OK (token valid)
GameService -> GameDB: INSERT INTO matches (size, strategy, difficulty, userId, status='ongoing')
GameDB --> GameService: matchId + persisted state
GameService --> Nginx: 201 Created\nmatch + initial YEN
Nginx --> Frontend: 201 Created\nmatch + initial YEN
Frontend -> Frontend: Update UI with game board
Frontend --> Human: Display empty board ready to play
----

*Notable Aspects:*

- The Game Service owns match lifecycle and persistence in `game.db`
- Initial game state is always stored and returned in YEN format
- React Frontend renders the game board based on received YEN notation
- Match creation requires authentication (JWT token verified against Auth Service)
- `auth.db` and `users.db` are not involved in this flow

=== Runtime Scenario 4: Player Move (Human Turn)

The human player submits a move by clicking on the game board in React.
The frontend sends the current game state to the Game Server for bot move computation, then persists the updated state in the Game Service.

[plantuml, "runtime-human-move", png]
----
actor "User (Browser)" as Human
participant "React Frontend" as Frontend
participant "Nginx" as Nginx
participant "Game Service\n(Node.js)" as GameService
participant "Game Server\n(Rust)" as Engine
database "game.db" as GameDB

Human -> Frontend: Click on board position
Frontend -> Frontend: Update local game state with player move

' 1) Request bot move from Game Server
Frontend -> Nginx: POST /api/gamey/ybot/choose/{botId}\n{position=YEN, strategy, difficulty}
Nginx -> Engine: Forward to port 4000
Engine -> Engine: Parse YEN\nValidate move\nCompute bot move
Engine --> Nginx: 200 OK\nYenMoveDto {move, status}
Nginx --> Frontend: YenMoveDto

alt invalid YEN or game finished
  Frontend --> Human: Display error message
else valid move
  Frontend -> Frontend: Apply bot move to local state\nUpdate YEN notation

  ' 2) Persist updated match state
  Frontend -> Nginx: POST /api/game/matches/{matchId}/moves\n{updatedYEN, status, moves}\nAuthorization: Bearer <token>
  Nginx -> GameService: Forward to port 3002
  GameService -> Auth: Verify JWT token
  Auth --> GameService: 200 OK (token valid)
  GameService -> GameService: Verify matchId ownership
  GameService -> GameDB: UPDATE matches SET state=updatedYEN, status=...\nINSERT INTO moves (...)
  GameDB --> GameService: OK
  GameService --> Nginx: 200 OK {updated match}
  Nginx --> Frontend: 200 OK {updated match}

  Frontend -> Frontend: Render updated board
  Frontend --> Human: Display updated game board
end
----

*Notable Aspects:*

- React Frontend coordinates the multi-step flow from the browser
- Game Server (Rust) is stateless and only computes moves based on YEN input, with no DB access
- Game Service is the authoritative source of match state persistence in `game.db`
- All updates are persisted atomically in `game.db`
- `auth.db` and `users.db` are not involved in this flow

=== Runtime Scenario 5: Bot API Interaction

External bots can play matches programmatically using the API.
The flow mirrors the human move scenario but uses bot credentials for authentication against the Auth Service.

[plantuml, "runtime-bot-api", png]
----
actor "Bot Client" as Bot
participant "Nginx" as Nginx
participant "Auth Service" as Auth
participant "Game Service" as GameService
participant "Game Server" as Engine
database "auth.db" as AuthDB
database "game.db" as GameDB

Bot -> Nginx: POST /api/gamey/bot/play\n{matchId, position=YEN, strategy, difficulty}\nAuthorization: Bearer <botToken>

' 1) Verify bot credentials
Nginx -> Auth: Verify botToken
Auth -> AuthDB: read token metadata
AuthDB --> Auth: token record
Auth --> Nginx: 200 OK (token valid)

' 2) Get match state
Nginx -> GameService: GET /api/game/matches/{matchId}
GameService -> GameDB: read match + status
GameDB --> GameService: match state/status
GameService --> Nginx: match state/status
Nginx -> Nginx: Check if match is ongoing

alt match finished or invalid
  Nginx --> Bot: 409 Conflict (game finished)\nor 401 Unauthorized
else match ongoing
  ' 3) Compute bot move
  Nginx -> Engine: POST /api/gamey/ybot/choose/{botId}\n{position=YEN}
  Engine -> Engine: Compute move
  Engine --> Nginx: YenMoveDto + status

  ' 4) Persist result
  Nginx -> GameService: POST /api/game/matches/{matchId}/moves\n{move, updatedYEN}
  GameService -> GameDB: persist move/result/stats
  GameDB --> GameService: OK
  GameService --> Nginx: OK + updated match

  Nginx --> Bot: 200 OK\nmove + updated YEN
end
----

*Notable Aspects:*

- Bot authentication is handled exclusively by Auth Service against `auth.db`
- Game data (match state, moves) is managed exclusively by Game Service against `game.db`
- External bots must follow the same YEN notation format as human players
- A failure in `users.db` does not affect bot gameplay

=== Runtime Scenario 6: Statistics and History Retrieval

Users can request aggregated statistics such as number of matches, wins/losses, and performance metrics through the React UI.
Statistics are served by the Game Service from `game.db`.

[plantuml, "runtime-stats", png]
----
actor "User (Browser)" as Human
participant "React Frontend" as Frontend
participant "Nginx" as Nginx
participant "Auth Service" as Auth
participant "Game Service\n(Node.js)" as GameService
database "game.db" as GameDB

Human -> Frontend: Navigate to Statistics page
Frontend -> Nginx: GET /api/game/stats/{userId}\nAuthorization: Bearer <token>
Nginx -> GameService: Forward to port 3002
GameService -> Auth: Verify JWT token
Auth --> GameService: 200 OK (token valid)
GameService -> GameDB: SELECT wins, losses, draws, total_matches\nFROM user_stats WHERE userId=...
GameDB --> GameService: stats/history records
GameService -> GameService: Aggregate and format stats
GameService --> Nginx: 200 OK\nStatsDto {wins, losses, draws, ...}
Nginx --> Frontend: StatsDto
Frontend -> Frontend: Render charts/tables
Frontend --> Human: Display statistics dashboard
----

*Notable Aspects:*

- Statistics are computed from persisted match data in `game.db`
- The Game Service exposes a unified Stats API
- React Frontend handles visualization (charts, tables)
- All stats queries require authentication (JWT verified against Auth Service)
- `auth.db` and `users.db` are not involved in this flow
