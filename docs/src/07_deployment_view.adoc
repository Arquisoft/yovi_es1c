ifndef::imagesdir[:imagesdir: ../images]

[[section-deployment-view]]
== Deployment View

The deployment view describes the technical infrastructure we use to run the Yovi system. It also shows how the software parts (building blocks) connect to that infrastructure. 

Because our system uses Docker containers, we describe the deployment in two main environments: the Production Environment and the Development Environment.

=== Infrastructure Level 1 - Production Environment

This section describes the main production environment where the final users can access the system.

_**Overview Diagram**_

.Production Deployment Diagram
image::deployment-level1-architecture.png[Level 1 Architecture Diagram, align="center"]

**Motivation**

The main goal of this deployment strategy is to find a good balance between working fast and keeping the system secure. Software needs hardware to run. By using a Virtual Machine (VM) as the main host, the system creates a secure border at the hardware level. Inside this VM, we use Docker containers to run the apps. This makes sure that the deployment is isolated and prevents problems with installed programs on the host machine.

**Quality and/or Performance Features**

* **Security (Defense in Depth):** The infrastructure has two layers of isolation. If a container is attacked, the VM acts as an external wall that protects the physical server. Also, the API Gateway is the only part connected to the public internet.
* **Portability:** By using Docker containers, the environment is always the same. The application works exactly the same way, no matter what physical server is running the Virtual Machine.
* **Independent Scalability:** The system is divided into specific microservices (Users, Gamey, API Gateway). Because of this, developers can give more resources to the Rust game engine without affecting the Node.js user management system.

**Mapping of Building Blocks to Infrastructure**

[cols="1,2", options="header"]
|===
| Software Artifact (Building Block) | Infrastructure Element

| **Web Application (React/Vite)**
| Deployed in a Docker container inside the VM. It serves the web interface (GUI) using static files over port 80 to the user's browser.

| **API Gateway (Nginx)**
| Deployed in a Docker container inside the VM. It works as a Reverse Proxy and is the only public entry point (Port 80/8080) to route the traffic.

| **User Management API (Node.js)**
| Deployed in a Docker container inside the VM (Port 3000). It manages user registration, login, and sessions.

| **GameY Engine API (Rust)**
| Deployed in a Docker container inside the VM (Port 4000). It calculates the math logic of the game and the bot movements in YEN format.

| **SQLite Database**
| A small database file saved on a Host Volume connected to the User Management container. This makes sure the data is not lost if the container restarts.
|===


=== Infrastructure Level 1 - Development Environment

Following the arc42 rules for multiple environments, the development environment uses the same Docker containers to be equal to production, but without the secure Virtual Machine.

**Motivation**

Developers need a fast and reliable environment to write and test code on their computers. We use Docker Compose to start the whole system on the developer's local machine.

**Quality and/or Performance Features**

* **Consistency:** It solves the classic "it works on my machine" problem.
* **Fast Setup:** A new developer can start the complete system (Frontend, APIs, and Database) with just one `docker-compose up` command.

**Mapping of Building Blocks to Infrastructure**

In this environment, the mapping is exactly the same as in Production. The only difference is the host hardware:
* **Infrastructure Element:** The developer's personal computer (Localhost) running Docker Desktop, instead of a Cloud Virtual Machine.


=== Infrastructure Level 2

Here we explain the internal structure of the Docker environment from Level 1. We zoom into the isolated network and how data is saved.

.Data Flow and Persistence Layer (Level 2)
image::deployment-level2-dataflow.png[Level 2 Data Flow Diagram, align="center"]

**Internal Structure Explanation:**

This level shows the internal Docker network rules. The **API Gateway (Nginx)** completely isolates the microservices from the public internet. External users can never reach the backend directly. 

Also, data storage is strictly controlled. The `SQLite` database is connected to a physical host volume. However, only the `User Management` container has permissions to read and write to this file. If the `GameY Engine` needs user data, it must ask via internal HTTP requests. This keeps the microservices properly separated.
