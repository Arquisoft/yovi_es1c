ifndef::imagesdir[:imagesdir: ../images]

[[section-deployment-view]]
== Deployment View

The deployment view describes the technical infrastructure we use to run the Yovi system. It also shows how the software parts (building blocks) connect to that infrastructure.

Because our system uses Docker containers, we describe the deployment in two main environments: the Production Environment and the Development Environment.

=== Infrastructure Level 1 - Production Environment

This section describes the main production environment where the final users can access the system.

_**Overview Diagram**_

.Production Deployment Diagram
image::deployment-level1-architecture.png[Level 1 Architecture Diagram, align="center"]

**Motivation**

The main goal of this deployment strategy is to find a good balance between working fast and keeping the system secure. Software needs hardware to run. By using a Virtual Machine (VM) as the main host, the system creates a secure border at the hardware level. Inside this VM, we use Docker containers to run the apps. This makes sure that the deployment is isolated and prevents problems with installed programs on the host machine.

**Quality and/or Performance Features**

* **Security (Defense in Depth):** The infrastructure has two layers of isolation. If a container is attacked, the VM acts as an external wall that protects the physical server. Also, the Nginx API Gateway is the only part connected to the public internet.
* **Portability:** By using Docker containers, the environment is always the same. The application works exactly the same way, no matter what physical server is running the Virtual Machine.
* **Independent Scalability:** The system is divided into specific microservices (React Frontend, Users Service, Game Server). Because of this, developers can give more resources to the Rust game engine without affecting the Node.js Users Service.
* **Separation of Concerns:** Users Service is the single point of access to the database, ensuring data consistency and security.

**Mapping of Building Blocks to Infrastructure**

[cols="1,2", options="header"]
|===
| Software Artifact (Building Block) | Infrastructure Element

| **React Frontend (Webapp)**
| Deployed as static files (HTML, CSS, JS bundle) served by Nginx on port 80. The React application runs entirely in the user's browser. Built with Vite and bundled for production.

| **Nginx (API Gateway)**
| Deployed in a Docker container inside the VM. It works as a Reverse Proxy and API Gateway. It is the only public entry point (Port 80) to route all incoming traffic. Handles CORS, rate limiting, and serves the React frontend static files. Routes API requests to backend services.

| **Users Service (Node.js + Express + TypeScript)**
| Deployed in a Docker container inside the VM (Port 3000, internal only). Single point of access to the database. Manages user registration, authentication, match persistence, and statistics. No other service can access the database directly.

| **Game Server (Rust)**
| Deployed in a Docker container inside the VM (Port 4000, internal only). It calculates the game logic and bot movements in YEN format. Stateless service optimized for performance. No database access.

| **SQLite Database**
| A database file saved on a Host Volume connected exclusively to the Users Service container. This makes sure the data is not lost if the container restarts. Only Users Service has read/write permissions.
|===


=== Infrastructure Level 1 - Development Environment

Following the arc42 rules for multiple environments, the development environment uses the same Docker containers to be equal to production, but without the secure Virtual Machine.

**Motivation**

Developers need a fast and reliable environment to write and test code on their computers. We use Docker Compose to start the whole system on the developer's local machine.

**Quality and/or Performance Features**

* **Consistency:** It solves the classic "it works on my machine" problem.
* **Fast Setup:** A new developer can start the complete system (React Frontend, Nginx, Users Service, Game Server, and Database) with just one `docker-compose up` command.

**Mapping of Building Blocks to Infrastructure**

In this environment, the mapping is exactly the same as in Production. The only difference is the host hardware:
* **Infrastructure Element:** The developer's personal computer (Localhost) running Docker Desktop, instead of a Cloud Virtual Machine.


=== Infrastructure Level 2

Here we explain the internal structure of the Docker environment from Level 1. We zoom into the isolated network and how data is saved.

.Data Flow and Persistence Layer (Level 2)
image::deployment-level2-dataflow.png[Level 2 Data Flow Diagram, align="center"]

**Internal Structure Explanation:**

This level shows the internal Docker network rules. The **Nginx API Gateway** completely isolates the microservices from the public internet. External users can never reach the backend services directly. All requests must go through Nginx on port 80.

The request flow is as follows:

* **User browser loads the app**: Nginx serves React static files (HTML, CSS, JS)
* **React app runs in browser**: Makes API calls to `/api/users/*` and `/api/gamey/*`
* **Nginx routes API requests** based on URL path:
** `/api/users/*` → Users Service (port 3000)
** `/api/gamey/*` → Game Server (port 4000)
** `/*` (all other paths) → React frontend static files

**Example User Flow:**

1. User opens `http://yourapp.com` in browser
2. Nginx serves `index.html` and React bundle from static files
3. React app loads in browser, displays login screen
4. User clicks "Login" → React sends `POST /api/users/auth/login` to Nginx
5. Nginx routes request to Users Service (port 3000)
6. Users Service validates credentials and returns JWT token
7. React stores token and makes game requests to `/api/gamey/play`
8. Nginx routes game requests to Game Server (port 4000)
9. Game Server returns move validation and updated game state in YEN format
10. React updates the UI with a new board state

Also, data storage is strictly controlled. The `SQLite` database is connected to a physical host volume. However, only the `Users Service` container has permissions to read and write to this file. The Game Server has no database access and operates in a completely stateless manner. If game state needs to be persisted (for match history), it must be sent to Users Service, which stores it in the database.

**Network Isolation:**

All backend services (Users Service, Game Server) run on an internal Docker network. They cannot be accessed directly from outside the VM. Only Nginx has a public-facing port (80) exposed to the internet. This architecture ensures that:

* Backend services are protected from direct attacks
* All requests go through Nginx security layers (rate limiting, CORS)
* Database is isolated behind Users Service
* Services communicate only through defined internal APIs
