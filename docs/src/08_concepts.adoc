ifndef::imagesdir[:imagesdir: ../images]

[[section-concepts]]
== Cross-cutting Concepts


ifdef::arc42help[]
[role="arc42help"]
****
.Content
This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system.
Such concepts are often related to multiple building blocks.
They can include many different topics, such as

* models, especially domain models
* architecture or design patterns
* rules for using specific technology
* principal, often technical decisions of an overarching (= cross-cutting) nature
* implementation rules


.Motivation
Concepts form the basis for _conceptual integrity_ (consistency, homogeneity) of the architecture.
Thus, they are an important contribution to achieve inner qualities of your system.

Some of these concepts cannot be assigned to individual building blocks, e.g. security or safety.


.Form
The form can be varied:

* concept papers with any kind of structure
* cross-cutting model excerpts or scenarios using notations of the architecture views
* sample implementations, especially for technical concepts
* reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping)

.Structure
A potential (but not mandatory) structure for this section could be:

* Domain concepts
* User Experience concepts (UX)
* Safety and security concepts
* Architecture and design patterns
* "Under-the-hood"
* development concepts
* operational concepts

Note: it might be difficult to assign individual concepts to one specific topic
on this list.

image::08-concepts-EN.drawio.png["Possible topics for crosscutting concepts"]


.Further Information

See https://docs.arc42.org/section-8/[Concepts] in the arc42 documentation.
****
endif::arc42help[]

=== Domain Model

A first version of the domain model of the application, representing all the entities
that interact with the application and their relations, is shown in the following
diagram:

[plantuml, "domain-model", png]
----
@startuml

class Player {
  +id(): PlayerId
  +name(): String
}

class PlayerId {
  +id(): u32
}

class GameY {
  .. game state ..
  +new(size: usize)
  +add_move(m: Movement)
  +render(options: RenderOptions)
}

class Movement {
}

class Coordinates {
  +from_index(idx: usize, size: usize)
  +to_index(size: usize)
}

class GameAction {
}

class YBot {
  <<trait>>
  +name(): &str
  +choose_move(board: &GameY): Option<Coordinates>
}

Player --> PlayerId : has >
Movement --> PlayerId : references >
Movement --> Coordinates : uses >
GameY --> Movement : records >
GameY --> Coordinates : uses >
YBot --> GameY : reads >
YBot --> Coordinates : returns >

@enduml
----

=== User experience (UX)

Since the project includes a web interface,
we wanted the user experience to be as smooth
and intuitive as possible. The idea is that anyone
can open the application and start playing without
needing instructions.

Key UX ideas:

• Visual Feedback: The interface reacts immediately
to user actions (valid moves, turn changes, errors).
This helps players understand what is happening in
the game at all times.

• Consistency: We try to keep the same style and
interaction patterns across all pages so the user
does not have to "relearn" how to use the app.

• Accessibility: Clear colors, readable text,
and simple layouts help make the game accessible
to a wider audience.

=== Safety and Security Concepts

Security is a cross‑cutting concern because it
affects both the backend services and the frontend.
Even though this is an academic project, we still apply basic security principles.

• **API Gateway Isolation:**
Nginx acts as the single public entry point, isolating backend services from direct external access. Only Nginx is exposed on port 80, while Users Service and Game Server run on internal Docker network ports.

• **Authentication and Authorization:**
Only authenticated users can access certain features, such as creating matches or viewing their profile. The Auth Service handles JWT authentication and exposes token verification for internal service-to-service authorization checks.

• **Password Protection:**
Passwords are never stored in plain text. Instead, they are hashed and salted before being saved in the database using bcrypt or Argon2.

• **Data Protection:**
We only store the minimum amount of user information needed for the system to work. Data is split by domain with strict ownership: `auth.db` is accessible only through Auth Service, `users.db` only through Users Service, and `game.db` only through Game Service.

• **CORS and Rate Limiting:**
Nginx handles Cross-Origin Resource Sharing (CORS) headers and rate limiting to prevent abuse and ensure legitimate API usage.

=== Architecture and Design Patterns

The system follows a microservice-based architecture. Instead of having one big monolithic
application, we split the project into several smaller, independent services:

• **React Frontend (webapp/):** The user interface running in the browser. It is a single-page application (SPA) built with React, Vite, and TypeScript. The frontend manages UI state and coordinates API calls to backend services.

• **Nginx:** The API Gateway and reverse proxy that routes requests to appropriate backend services. It handles CORS, rate limiting, and serves the React frontend static files.

• **Auth Service (auth/):** Node.js + Express + TypeScript service that manages registration, authentication (JWT access/refresh lifecycle), and internal token verification. It is the single point of access to `auth.db`.

• **Users Service (users/):** Node.js + Express + TypeScript service that manages user profiles, match persistence, and statistics. It is the single point of access to `users.db`.

• **Game Server (gamey/):** Rust service that implements the Y‑game engine and bot logic. It is stateless and focuses purely on game rules, move validation, and bot strategies.

Some patterns we use:

**API Gateway Pattern:**
Nginx centralizes all external requests and routes them to the appropriate service based on URL paths (`/api/users/*`, `/api/gamey/*`, `/`).

**Repository Pattern:**
The Users Service uses the Repository pattern to abstract database access, making it easier to test and maintain.

**Strategy Pattern:**
The Game Server uses the Strategy pattern to implement multiple bot difficulty levels (random, heuristic) in an extensible way.

**Separation of Concerns:**
The frontend separates UI components, state management (React hooks/context), and API call logic into distinct layers.

=== Development Concepts

These concepts describe the practices that the whole team follows during development.

**Version Control:**

The project is developed collaboratively using GitHub. Branching, pull requests and code reviews
ensure that all components evolve consistently.

**Testing:**

Each part of the system includes automated tests:

• Rust Game Server: unit tests for game logic and strategies
• Users Service (Node.js): API endpoint tests and integration tests
• React Frontend: component tests and end-to-end tests

Testing is transversal because it guarantees correctness across all services.

**Continuous Integration:**

GitHub Actions automatically run builds and tests whenever code is pushed.
This helps detect errors early and keeps all services aligned.

=== Persistence Layer

The application relies on SQL databases (SQLite - relational database) split by domain: `auth.db`, `users.db`, and `game.db`.

Each database is accessed exclusively by its owning service. This design decision ensures:

• **Data Consistency:** each service manages transactions in its own domain
• **Security:** other services cannot directly access or modify another service's database
• **Separation of Concerns:** Auth handles credentials/tokens, Users handles profiles/statistics, and Game handles match state

Game sessions are computed in memory by the Rust Game Server and persisted to `game.db` when needed (history/resume). Credentials and token metadata remain exclusive to Auth Service in `auth.db`.

If additional persistence requirements arise in the future (for example, caching or match replay functionality), the system can be extended without affecting the existing services thanks to the microservice-based design.

=== Error Handling

The application includes a consistent error handling strategy to deal with the different types of errors that may
appear during execution. The goal is to detect problems early, avoid unexpected crashes and provide clear feedback
both to developers and to users.

At the user level, the application only displays simple and understandable messages, without exposing technical
details. This prevents confusion and avoids leaking internal information. On the other hand, the backend services
and the Rust game engine generate structured error messages and log them internally so developers can identify the
cause of the problem more easily.

**Error Handling Across Services:**

• **React Frontend:** Displays user-friendly error messages for API failures, invalid moves, or authentication errors. Uses try-catch blocks and error boundaries for React component errors.

• **Nginx:** Returns standard HTTP error codes (400, 401, 404, 500) and logs errors for monitoring.

• **Users Service:** Validates input, handles database errors, and returns appropriate HTTP status codes with error messages. Uses middleware for centralized error handling.

• **Game Server:** Returns structured error responses for invalid YEN notation, illegal moves, or computation failures. Rust's Result type ensures explicit error handling.
